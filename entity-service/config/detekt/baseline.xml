<?xml version="1.0" ?>
<SmellBaseline>
  <ManuallySuppressedIssues></ManuallySuppressedIssues>
  <CurrentIssues>
    <ID>EmptyCatchBlock:EntitiesGraphBuilder.kt$EntitiesGraphBuilder${ }</ID>
    <ID>EmptyFunctionBlock:StandaloneAuthorizationService.kt$StandaloneAuthorizationService${}</ID>
    <ID>ForbiddenComment:RepositoryEventsListener.kt$RepositoryEventsListener$// TODO: For deserialization in other modules Jackson can be used with the entityEvent model that gives a payload and an updatedEntity in a proper json format</ID>
    <ID>LargeClass:EntityHandlerTests.kt$EntityHandlerTests</ID>
    <ID>LargeClass:EntityServiceTests.kt$EntityServiceTests</ID>
    <ID>LargeClass:Neo4jRepositoryTests.kt$Neo4jRepositoryTests</ID>
    <ID>LongMethod:EntityHandlerTests.kt$EntityHandlerTests$@Test fun `entity attributes update should send two notification if two attributes are updated`()</ID>
    <ID>LongMethod:EntityService.kt$EntityService$ fun getFullEntityById(entityId: String): JsonLdEntity</ID>
    <ID>LongMethod:EntityService.kt$EntityService$// TODO send append events to Kafka @Transactional fun appendEntityAttributes( entityId: String, attributes: List&lt;NgsiLdAttribute&gt;, disallowOverwrite: Boolean ): UpdateResult</ID>
    <ID>LongMethod:EntityServiceTests.kt$EntityServiceTests$@Test fun `it should create a new multi attribute property`()</ID>
    <ID>LongParameterList:Attribute.kt$Attribute$( @Transient val attributeType: String, var observedAt: ZonedDateTime? = null, @JsonIgnore val createdAt: ZonedDateTime = Instant.now().atZone(ZoneOffset.UTC), @JsonIgnore var modifiedAt: ZonedDateTime? = null, @Convert(UriConverter::class) var datasetId: URI? = null, @Relationship(type = "HAS_VALUE") val properties: MutableList&lt;Property&gt; = mutableListOf(), @Relationship(type = "HAS_OBJECT") val relationships: MutableList&lt;com.egm.stellio.entity.model.Relationship&gt; = mutableListOf() )</ID>
    <ID>LongParameterList:Entity.kt$Entity$( @Id @JsonProperty("@id") @Convert(UriConverter::class) val id: URI, @Labels @JsonProperty("@type") val type: List&lt;String&gt;, @JsonIgnore val createdAt: ZonedDateTime = Instant.now().atZone(ZoneOffset.UTC), @JsonIgnore var modifiedAt: ZonedDateTime? = null, @JsonIgnore var location: GeographicPoint2d? = null, @Relationship(type = "HAS_VALUE") val properties: MutableList&lt;Property&gt; = mutableListOf(), @Relationship(type = "HAS_OBJECT") val relationships: MutableList&lt;com.egm.stellio.entity.model.Relationship&gt; = mutableListOf(), var contexts: List&lt;String&gt; = mutableListOf() )</ID>
    <ID>MaxLineLength:EntityHandlerTests.kt$EntityHandlerTests$ </ID>
    <ID>MaxLineLength:EntityHandlerTests.kt$EntityHandlerTests$/** * As Spring's ApplicationEventPublisher is not easily mockable (https://github.com/spring-projects/spring-framework/issues/18907), * we are directly mocking the event listener to check it receives what is expected */ @MockkBean private lateinit var repositoryEventsListener: RepositoryEventsListener</ID>
    <ID>MaxLineLength:EntityHandlerTests.kt$EntityHandlerTests${ val fishNumberPayload = """ "fishNumber":{ "type":"Property", "value":600 } """.trimIndent() val fishNamePayload = """ "fishName":{ "type":"Property", "value":"Salmon", "unitCode": "C1" } """.trimIndent() val jsonPayload = """ { $fishNumberPayload, $fishNamePayload } """.trimIndent() val entityId = "urn:ngsi-ld:DeadFishes:019BN" every { entityService.exists(any()) } returns true every { entityService.updateEntityAttributes( any(), any() ) } returns UpdateResult( updated = arrayListOf( "https://ontology.eglobalmark.com/aquac#fishName", "https://ontology.eglobalmark.com/aquac#fishNumber" ), notUpdated = arrayListOf() ) val events = mutableListOf&lt;EntityEvent&gt;() every { repositoryEventsListener.handleRepositoryEvent(capture(events)) } just Runs every { authorizationService.userCanUpdateEntity(entityId, "mock-user") } returns true webClient.patch() .uri("/ngsi-ld/v1/entities/$entityId/attrs") .header("Link", "&lt;$aquacContext&gt;; rel=http://www.w3.org/ns/json-ld#context; type=application/ld+json") .contentType(MediaType.APPLICATION_JSON) .bodyValue(jsonPayload) .exchange() .expectStatus().isNoContent verify(timeout = 1000, exactly = 2) { repositoryEventsListener.handleRepositoryEvent(any()) } assertEquals(2, events.size) events.forEach { entityEvent -&gt; assertTrue( entityEvent.entityId == entityId &amp;&amp; entityEvent.operationType == EventType.UPDATE &amp;&amp; ( "{$fishNumberPayload}".matchContent(entityEvent.payload) || "{$fishNamePayload}".matchContent(entityEvent.payload) ) &amp;&amp; entityEvent.updatedEntity == null ) } // I don't know where does this call come from (probably a Spring internal thing) but it is required for verification verify { repositoryEventsListener.equals(any()) } confirmVerified(repositoryEventsListener) }</ID>
    <ID>MaxLineLength:EntityHandlerTests.kt$EntityHandlerTests${ val jsonPayload = loadSampleData("aquac/fragments/DeadFishes_partialAttributeUpdate.json") val entityId = "urn:ngsi-ld:DeadFishes:019BN" every { entityService.exists(any()) } returns true every { entityService.updateEntityAttributes( any(), any() ) } returns UpdateResult( updated = arrayListOf("https://ontology.eglobalmark.com/aquac#fishNumber"), notUpdated = arrayListOf() ) every { repositoryEventsListener.handleRepositoryEvent(any()) } just Runs every { authorizationService.userCanUpdateEntity(entityId, "mock-user") } returns true webClient.patch() .uri("/ngsi-ld/v1/entities/$entityId/attrs") .header("Link", "&lt;$aquacContext&gt;; rel=http://www.w3.org/ns/json-ld#context; type=application/ld+json") .contentType(MediaType.APPLICATION_JSON) .bodyValue(jsonPayload) .exchange() .expectStatus().isNoContent verify(timeout = 1000, exactly = 1) { repositoryEventsListener.handleRepositoryEvent( match { entityEvent -&gt; entityEvent.entityId == entityId &amp;&amp; entityEvent.operationType == EventType.UPDATE &amp;&amp; jsonPayload.matchContent(entityEvent.payload) &amp;&amp; entityEvent.updatedEntity == null } ) } // I don't know where does this call come from (probably a Spring internal thing) but it is required for verification verify { repositoryEventsListener.equals(any()) } confirmVerified(repositoryEventsListener) }</ID>
    <ID>MaxLineLength:EntityServiceTests.kt$EntityServiceTests$ {</ID>
    <ID>MaxLineLength:EntityServiceTests.kt$EntityServiceTests$/** * As Spring's ApplicationEventPublisher is not easily mockable (https://github.com/spring-projects/spring-framework/issues/18907), * we are directly mocking the event listener to check it receives what is expected */ @MockkBean private lateinit var repositoryEventsListener: RepositoryEventsListener</ID>
    <ID>MaxLineLength:EntityServiceTests.kt$EntityServiceTests${ val expectedPayloadInEvent = """ {"id":"urn:ngsi-ld:MortalityRemovalService:014YFA9Z","type":"MortalityRemovalService","@context":["https://raw.githubusercontent.com/easy-global-market/ngsild-api-data-models/master/shared-jsonld-contexts/egm.jsonld","https://raw.githubusercontent.com/easy-global-market/ngsild-api-data-models/master/aquac/jsonld-contexts/aquac.jsonld","http://uri.etsi.org/ngsi-ld/v1/ngsi-ld-core-context.jsonld"]} """.trimIndent() val sampleDataWithContext = parseSampleDataToNgsiLd("aquac/MortalityRemovalService_standalone.json") val mockedBreedingService = mockkClass(Entity::class) every { entityRepository.exists(eq("urn:ngsi-ld:MortalityRemovalService:014YFA9Z")) } returns false every { entitiesGraphBuilder.build(any()) } returns Pair(DirectedPseudograph&lt;NgsiLdEntity, DefaultEdge&gt;(DefaultEdge::class.java), emptyList()) every { entityRepository.save&lt;Entity&gt;(any()) } returns mockedBreedingService every { repositoryEventsListener.handleRepositoryEvent(any()) } just Runs every { mockedBreedingService.properties } returns mutableListOf() every { mockedBreedingService.id } returns "urn:ngsi-ld:MortalityRemovalService:014YFA9Z" every { entityRepository.getEntityCoreById(any()) } returns mockedBreedingService every { mockedBreedingService.serializeCoreProperties() } returns mutableMapOf( "@id" to "urn:ngsi-ld:MortalityRemovalService:014YFA9Z", "@type" to listOf("MortalityRemovalService") ) every { entityRepository.getEntitySpecificProperties(any()) } returns listOf() every { entityRepository.getEntityRelationships(any()) } returns listOf() every { mockedBreedingService.contexts } returns sampleDataWithContext.contexts entityService.createEntity(sampleDataWithContext) verify(timeout = 1000, exactly = 1) { repositoryEventsListener.handleRepositoryEvent( match { entityEvent -&gt; entityEvent.entityType == "MortalityRemovalService" &amp;&amp; entityEvent.entityId == "urn:ngsi-ld:MortalityRemovalService:014YFA9Z" &amp;&amp; entityEvent.operationType == EventType.CREATE &amp;&amp; entityEvent.payload == expectedPayloadInEvent &amp;&amp; entityEvent.updatedEntity == null } ) } // I don't know where does this call come from (probably a Spring internal thing) but it is required for verification verify { repositoryEventsListener.equals(any()) } confirmVerified(repositoryEventsListener) }</ID>
    <ID>MaxLineLength:Neo4jAuthorizationRepository.kt$Neo4jAuthorizationRepository$ MATCH (userEntity)-[:HAS_OBJECT]-&gt;(:Attribute:Relationship)-[:IS_MEMBER_OF]-&gt;(:Entity)-[:HAS_OBJECT]-(grpRight:Attribute:Relationship)-[]-&gt;(entity:Entity)</ID>
    <ID>MaxLineLength:Neo4jAuthorizationRepository.kt$Neo4jAuthorizationRepository$ OPTIONAL MATCH (userEntity)-[:HAS_OBJECT]-(r:Attribute:Relationship)-[:IS_MEMBER_OF]-&gt;(group:Entity)-[:HAS_VALUE]-&gt;</ID>
    <ID>MaxLineLength:Neo4jRepository.kt$Neo4jRepository$ CREATE (subject)-[:HAS_OBJECT]-&gt;(r:Attribute:Relationship:`</ID>
    <ID>MaxLineLength:Neo4jRepository.kt$Neo4jRepository$ MATCH (a:</ID>
    <ID>MaxLineLength:Neo4jRepository.kt$Neo4jRepository$ MATCH (a:Attribute { id: </ID>
    <ID>MaxLineLength:Neo4jRepository.kt$Neo4jRepository$ MATCH (entity:</ID>
    <ID>MaxLineLength:Neo4jRepository.kt$Neo4jRepository$ MATCH (m:Property)-[:HAS_OBJECT]-()-[:OBSERVED_BY]-&gt;(e:Entity)-[:HAS_OBJECT]-()-[:IS_CONTAINED_IN]-&gt;(device:Entity)-[:HAS_VALUE]-&gt;(deviceProp:Property)</ID>
    <ID>MaxLineLength:RepositoryEventsListener.kt$RepositoryEventsListener$// TODO: For deserialization in other modules Jackson can be used with the entityEvent model that gives a payload and an updatedEntity in a proper json format @Async @EventListener fun handleRepositoryEvent(entityEvent: EntityEvent)</ID>
    <ID>MaxLineLength:WebSecurityTestConfig.kt$WebSecurityTestConfig : WebSecurityConfig</ID>
    <ID>NestedBlockDepth:EntityService.kt$EntityService$@Transactional fun updateEntityAttributes(id: URI, attributes: List&lt;NgsiLdAttribute&gt;): UpdateResult</ID>
    <ID>ReturnCount:EntityHandler.kt$EntityHandler$ @GetMapping(produces = [MediaType.APPLICATION_JSON_VALUE, JSON_LD_CONTENT_TYPE]) suspend fun getEntities( @RequestHeader httpHeaders: HttpHeaders, @RequestParam params: MultiValueMap&lt;String, String&gt; ): ResponseEntity&lt;*&gt;</ID>
    <ID>TooGenericExceptionCaught:ObservationListener.kt$ObservationListener$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ParsingUtils.kt$e: Exception</ID>
    <ID>TooManyFunctions:EntityService.kt$EntityService$EntityService</ID>
    <ID>TooManyFunctions:Neo4jRepository.kt$Neo4jRepository$Neo4jRepository</ID>
  </CurrentIssues>
</SmellBaseline>
